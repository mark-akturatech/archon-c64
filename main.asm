#import "io.asm"
#import "const.asm"

BasicUpstart2(entry)

//---------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------
// Archon (c) 1983
//
// This is NOT a byte for byte replication as the original code has a lot of decryption and copy code that detracts
// from the code understanding. Therefore, the code below uses the untouched souce code where possible, however
// memory is reorganised and copy, decription and obfuscation code is removed.
//
// The code was generated by loading the `Archon (1983)(Electronic Arts).t64` file in Vice and placing a breakpoint
// at 6100. All code prior to this is decryption, obfuscation and moving stuff around in memory.
//---------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------

entry: 
    // configure vic memory as follows (number shown are offsets. add video memory start address):
    //
    //   0000 -+- intro character set
    //   ...   |
    //   ...   |    0400 -+- screen memory
    //   ...   |    ...   |
    //   07ff -+    07e76 +
    //   0800 -+- board character set
    //   ...   |
    //   ...   |
    //   0fff -+
    //   1000 -+- sprite memory
    //   ...   |
    //   ...   |
    //   2000 -+
    //
    // as can be seen, the screen memory overlaps the first character set. this is OK as the first character set
    // contains lower case only characters and therefore occupies only half of the memory of a full character set.
    jsr import_title_charset
    jsr import_board_charset
    jsr init
    jsr clear_screen
    jsr clear_sprites
    .break
    rts

// import the title charset in to the lower character memory
import_title_charset:
    lda #<title_charset
    sta FREEZP
    lda #>title_charset
    sta FREEZP+1
    lda #<CHRMEM1
    sta FREEZP+2
    lda #>CHRMEM1
    sta FREEZP+3
    ldx #$02
import_charset:
    ldy #$00
!loop:
    lda (FREEZP), y
    sta (FREEZP+2), y
    iny
    bne !loop-
    inc FREEZP+1
    inc FREEZP+3
    dex 
    bne !loop-
    rts 

// import the board charset in to the upper character memory
import_board_charset:
    lda #<board_charset
    sta FREEZP
    lda #>board_charset
    sta FREEZP+1
    lda #<CHRMEM2
    sta FREEZP+2
    lda #>CHRMEM2
    sta FREEZP+3
    ldx #$04
    jmp import_charset

init:
    // not sure why yet - allows writing of ATTN and TXD on serial port
    lda C2DDRA
    ora #%0000_0011
    sta C2DDRA

    // set VIC memory bank
    // Original code uses Bank #1 ($4000-$7FFF) hwoever We will use Bank #2 ($8000-$BFFF) so we can fit Archon within
    // basic memory (hopefully).
    lda CI2PRA
    and #%1111_1100
    .if (VICMEM == $0000) ora #%0000_0011
    .if (VICMEM == $4000) ora #%0000_0010
    .if (VICMEM == $8000) ora #%0000_0001
    .if (VICMEM == $C000) ora #%0000_0000
    sta CI2PRA

    // set text mode character memory to $0800-$0FFF (+VIC bank offset as set in CI2PRA)
    // set character dot data to $0400-$07FF (+VIC bank offset as set in CI2PRA)
    lda #%0001_0010
    sta VMCSB

    // set RAM visible at $A000-$BFFF
    lda R6510
    and #%1111_1110
    sta R6510

    // configure interrupt handler routines
    //
    // the interrupt handler calls the standard system interrupt if a raster interrupt is detected. this is used to
    // draw the screen. otherwise it calls a minimlaist interrupt routine presumably for optimization.
    //
    // to set the interrupts, we need to disable interrupts, configure the interrupt call pointers, stop raster scan
    // interrupts and then point the interrupt handler away from the system handler to our new handler. we can then
    // re-enable scan interupts and exit.
    sei
    lda #<quick_interupt_handler
    sta non_raster_int_ptr
    lda #>quick_interupt_handler
    sta non_raster_int_ptr+1
    lda CINV
    sta raster_int_ptr
    lda CINV+1
    sta raster_int_ptr+1
    // disable raster interrupts
    lda IRQMASK
    and #%0111_1110
    sta IRQMASK
    // set interrupt handler 
    lda #<interrupt_handler
    sta CINV
    sta CBINV
    lda #>interrupt_handler
    sta CINV+1
    sta CBINV+1
    // set raster line used to trigger on raster interrupt
    // as there are 262 lines, the line number is set by setting the highest bit of $D011 and the 8 bits in $D012
    lda SCROLY
    and #%0111_1111
    sta SCROLY
    lda #251
    sta RASTER
    // reenable raster interrupts
    lda IRQMASK
    ora #%1000_0001
    sta IRQMASK
    cli
    rts

// clear the video screen area
// loads $00 to the video matrix SCNMEM to SCNMEM+$3E7
clear_screen:
    lda #<SCNMEM
    sta FREEZP+2
    lda #>SCNMEM
    sta FREEZP+3
    ldx #$03
    lda #$00
    tay
!loop:
    sta (FREEZP+2), y
    iny
    bne !loop-
    inc FREEZP+3
    dex 
    bne !loop-
!loop:
    sta (FREEZP+2), y
    iny
    cpy #$e8
    bcc !loop-
    rts    

// clear the video graphics area
clear_sprites:
    lda #<GRPMEM
    sta FREEZP+2
    lda #>GRPMEM
    sta FREEZP+3
    ldx #$10
    lda #$00
    tay
!loop:
    sta (FREEZP+2), y
    iny
    bne !loop-
    inc FREEZP+3
    dex 
    bne !loop-
    // reset sprite positions
    ldx #$07
    sta MSIGX
!loop:
    sta SP0X, x
    dex
    bpl !loop-
    rts

// call our interrupt handlers
// we call a different handler if the interrupt was triggered by a raster line compare event
interrupt_handler:
    lda VICIRQ
    and #%0000_0001
    beq raster_interrupt
    sta VICIRQ // needed to clear the interrupt flag
    jmp (non_raster_int_ptr)
raster_interrupt:
    jmp (raster_int_ptr)

// minimalist interrupt handler
quick_interupt_handler:
    pla
    tay
    pla
    tax
    pla
    rti

//---------------------------------------------------------------------------------------------------------------------
// storage

// address used by interrupt handler if a non-raster scan interrupt is detected
non_raster_int_ptr:
    .byte 0, 0
    
// address used by interrupt handler if a raster scan interrupt is detected
raster_int_ptr:
    .byte 0, 0

//---------------------------------------------------------------------------------------------------------------------
// binaries

title_charset:
    .import binary "assets/title-charset.bin"

board_charset:
    .import binary "assets/board-charset.bin"

/*
// source start: A835
configure:
    // configure screen
    lda SCROLX
    and #%1110_1111     // multicolor bitmap mode off
    sta SCROLX
    lda #%0001_0000     // $0000-$07FF char memory, $2000-$23FF screen memory
    sta VMCSB
    // configure sprites
    lda #%0000_1111     // first 4 sprites multicolor; last 4 sprints single color
    sta SPMC
    lda #%1111_0000     // first 4 sprites double width; last 4 sprites single width
    sta XXPAND
    lda #%1111_1111     // enable all sprites
    sta SPENA
    //
// sei                        
// lda  #$42
// sta  $BCCC
// lda  #$AA
// WA859:
// sta  $BCCD
// cli
// lda  #$00                  
// sta  $BCC7
// sta  $D020
// sta  $D021
// A868  AD 88 A9   LDA  $A988                 BASIC ROM
// A86B  8D 25 D0   STA  WD025                 Multicolor animation 0 register
// A86E  8D 26 D0   STA  WD026                 Multicolor animation 1 register
// A871  A9 56      LDA  #$56                  
// A873  8D 30 BD   STA  WBD30                 BASIC ROM
// A876  A9 AA      LDA  #$AA                  
// A878  8D 31 BD   STA  WBD31                 BASIC ROM    
    rts


intro:
    rts



*/
