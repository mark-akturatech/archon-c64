//---------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------
// Archon (c) 1983
//
// This is NOT a byte for byte replication as the original code has a lot of decryption and copy code that detracts
// from the code understanding. Therefore, the code below uses the untouched souce code where possible, however
// memory is reorganised and copy, decription and obfuscation code is removed.
//
// The code was generated by loading the `Archon (1983)(Electronic Arts).t64` file in Vice and placing a breakpoint
// at 6100. All code prior to this is decryption, obfuscation and moving stuff around in memory.
//---------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------
#import "io.asm"
#import "const.asm"

.file [name="main.prg", segments="Upstart, Main, Intro, Game, Data, Binaries"]
.segmentdef Upstart
.segmentdef Main [startAfter="Upstart"]
.segmentdef Intro [startAfter="Main"]
.segmentdef Game [startAfter="Intro"]
.segmentdef Data [startAfter="Game"]
.segmentdef Binaries [startAfter="Data", align=$100]

#import "unofficial.asm"
#import "intro.asm"
#import "game.asm"

//---------------------------------------------------------------------------------------------------------------------
// Basic Upstart
//---------------------------------------------------------------------------------------------------------------------
// create basic program with sys command to execute code
.segment Upstart
BasicUpstart2(entry)

//---------------------------------------------------------------------------------------------------------------------
// Entry
//---------------------------------------------------------------------------------------------------------------------
.segment Main
entry:
    // Configure vic memory as follows (number shown are offsets. add video memory start address):
    //
    //   0000 -+- intro character set
    //   ...   |
    //   ...   |   0400 -+- screen memory
    //   ...   |   ...   |
    //   ...   |   07ef7 +
    //   ...   |   07ef8 +- sprite location memory
    //   ...   |   ...   |
    //   07ff -+   07eff +
    //   0800 -+- board character set
    //   ...   |
    //   ...   |
    //   0fff -+
    //   1000 -+- sprite memory
    //   ...   |
    //   ...   |
    //   2000 -+
    //
    // As can be seen, the screen memory overlaps the first character set. this is OK as the first character set
    // contains lower case only characters and therefore occupies only half of the memory of a full character set.
    //
    // Here we also create an interrupt handler. The handler calls configurable routines based on whether the interrupt
    // was generated by a raster interrupt or a general system interrupt. Each game state (intro, board setup, game
    // play) registers different routines fo rthe handler.
    //
    // During initialization, the interrupt handler is configured as follows:
    // - System interrupt: call minimalist interrupt handler (just restores the x, y, a registers from the stack and
    //   returns).
    // - Raster interrupt: calls default kernal interrupt handler ($ea31)
    jsr init

    // Call the main game loops for each game state.
    jsr intro
    jsr game

    .break
    rts

init:
    // not sure why yet - allows writing of ATTN and TXD on serial port
    lda C2DDRA
    ora #%0000_0011
    sta C2DDRA

    // set VIC memory bank
    // Original code uses Bank #1 ($4000-$7FFF) hwoever We will use Bank #2 ($8000-$BFFF) so we can fit Archon within
    // basic memory (hopefully).
    lda CI2PRA
    and #%1111_1100
    ora #VICBANK
    sta CI2PRA

    // set text mode character memory to $0800-$0FFF (+VIC bank offset as set in CI2PRA)
    // set character dot data to $0400-$07FF (+VIC bank offset as set in CI2PRA)
    lda #%0001_0010
    sta VMCSB

    // set RAM visible at $A000-$BFFF
    lda R6510
    and #%1111_1110
    sta R6510

    // configure interrupt handler routines
    // the interrupt handler calls the standard system interrupt if a raster interrupt is detected. this is used to
    // draw the screen. otherwise it calls a minimlaist interrupt routine presumably for optimization.
    // to set the interrupts, we need to disable interrupts, configure the interrupt call pointers, stop raster scan
    // interrupts and then point the interrupt handler away from the system handler to our new handler. we can then
    // re-enable scan interupts and exit.
    sei
    lda #<quick_interupt_handler
    sta interruptPointer.system
    lda #>quick_interupt_handler
    sta interruptPointer.system+1
    lda CINV
    sta interruptPointer.raster
    lda CINV+1
    sta interruptPointer.raster+1
    // disable raster interrupts
    lda IRQMASK
    and #%0111_1110
    sta IRQMASK
    // set interrupt handler 
    lda #<interrupt_handler
    sta CINV
    sta CBINV
    lda #>interrupt_handler
    sta CINV+1
    sta CBINV+1
    // set raster line used to trigger on raster interrupt
    // as there are 262 lines, the line number is set by setting the highest bit of $D011 and the 8 bits in $D012
    lda SCROLY
    and #%0111_1111
    sta SCROLY
    lda #251
    sta RASTER
    // reenable raster interrupts
    lda IRQMASK
    ora #%1000_0001
    sta IRQMASK
    cli
    rts

// call our interrupt handlers
// we call a different handler if the interrupt was triggered by a raster line compare event
interrupt_handler:
    lda VICIRQ
    and #%0000_0001
    beq raster_interrupt
    sta VICIRQ // needed to clear the interrupt flag
    jmp (interruptPointer.system)
raster_interrupt:
    jmp (interruptPointer.raster)

// minimalist interrupt handler
quick_interupt_handler:
    pla
    tay
    pla
    tax
    pla
    rti

// clear the video screen area
// loads $00 to the video matrix SCNMEM to SCNMEM+$3E7
clear_screen:
    lda #<SCNMEM
    sta FREEZP+2
    lda #>SCNMEM
    sta FREEZP+3
    ldx #$03
    lda #$00
    tay
!loop:
    sta (FREEZP+2), y
    iny
    bne !loop-
    inc FREEZP+3
    dex 
    bne !loop-
!loop:
    sta (FREEZP+2), y
    iny
    cpy #$e8
    bcc !loop-
    rts    

// clear the video graphics area
clear_sprites:
    lda #<GRPMEM
    sta FREEZP+2
    lda #>GRPMEM
    sta FREEZP+3
    ldx #$10
    lda #$00
    tay
!loop:
    sta (FREEZP+2), y
    iny
    bne !loop-
    inc FREEZP+3
    dex 
    bne !loop-
    // reset sprite positions
    ldx #$07
    sta MSIGX
!loop:
    sta SP0X, x
    dex
    bpl !loop-
    rts

//---------------------------------------------------------------------------------------------------------------------
// Data
//---------------------------------------------------------------------------------------------------------------------
.segment Data

// interrupt handler pointers
.namespace interruptPointer {
    system: .word 0 // system interrupt handler
    raster: .word 0 // raster interrupt handler
}
