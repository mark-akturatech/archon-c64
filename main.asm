//---------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------
// Archon (c) 1983
//
// This is NOT a byte for byte replication as the original code has a lot of decryption and copy code that detracts
// from the code understanding. Therefore, the code below uses the untouched souce code where possible, however
// memory is reorganised and copy, decription and obfuscation code is removed.
//
// The code was generated by loading the `Archon (1983)(Electronic Arts).t64` file in Vice and placing a breakpoint
// at 6100. All code prior to this is decryption, obfuscation and moving stuff around in memory.
//---------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------
#import "src/io.asm"
#import "src/const.asm"

.file [name="main.prg", segments="Upstart, Main, Intro, Game, Variables, Assets"]

.segmentdef Upstart
.segmentdef Main [startAfter="Upstart"]
.segmentdef Intro [startAfter="Main"]
.segmentdef Game [startAfter="Intro"]
.segmentdef Variables [startAfter="Game"]
.segmentdef Assets [startAfter="Variables", align=$100]

#import "src/unofficial.asm"
#if INCLUDE_INTRO
    #import "src/intro.asm"
#endif
#import "src/game.asm"

//---------------------------------------------------------------------------------------------------------------------
// Basic Upstart
//---------------------------------------------------------------------------------------------------------------------
// create basic program with sys command to execute code
.segment Upstart
BasicUpstart2(entry)

//---------------------------------------------------------------------------------------------------------------------
// Entry
//---------------------------------------------------------------------------------------------------------------------
.segment Main
entry:
    // Configure vic memory as follows (number shown are offsets. add video memory start address):
    //
    //   0000 -+- intro character set
    //   ...   |
    //   ...   |   0400 -+- screen memory
    //   ...   |   ...   |
    //   ...   |   07ef7 +
    //   ...   |   07ef8 +- sprite location memory
    //   ...   |   ...   |
    //   07ff -+   07eff +
    //   0800 -+- board character set
    //   ...   |
    //   ...   |
    //   0fff -+
    //   1000 -+- sprite memory
    //   ...   |
    //   ...   |
    //   2000 -+
    //
    // As can be seen, the screen memory overlaps the first character set. this is OK as the first character set
    // contains lower case only characters and therefore occupies only half of the memory of a full character set.
    //
    // Here we also create an interrupt handler. The handler calls configurable routines based on whether the interrupt
    // was generated by a raster interrupt or a general system interrupt. Each game state (intro, board setup, game
    // play) registers different routines fo rthe handler.
    //
    // During initialization, the interrupt handler is configured as follows:
    // - System interrupt: call minimalist interrupt handler (just restores the x, y, a registers from the stack and
    //   returns).
    // - Raster interrupt: calls default kernal interrupt handler ($ea31)
    jsr init

    // Call the main game loops for each game state.
#if INCLUDE_INTRO
    jsr intro.entry
#endif    
    jsr game.entry

    .break
    rts

init:
    // not sure why yet - allows writing of ATTN and TXD on serial port
    lda C2DDRA
    ora #%0000_0011
    sta C2DDRA

    // set VIC memory bank
    // Original code uses Bank #1 ($4000-$7FFF) hwoever We will use Bank #2 ($8000-$BFFF) so we can fit Archon within
    // basic memory (hopefully).
    lda CI2PRA
    and #%1111_1100
    ora #VICBANK
    sta CI2PRA

    // set text mode character memory to $0800-$0FFF (+VIC bank offset as set in CI2PRA)
    // set character dot data to $0400-$07FF (+VIC bank offset as set in CI2PRA)
    lda #%0001_0010
    sta VMCSB

    // set RAM visible at $A000-$BFFF
    lda R6510
    and #%1111_1110
    sta R6510

    // configure interrupt handler routines
    // the interrupt handler calls the standard system interrupt if a raster interrupt is detected. this is used to
    // draw the screen. otherwise it calls a minimlaist interrupt routine presumably for optimization.
    // to set the interrupts, we need to disable interrupts, configure the interrupt call pointers, stop raster scan
    // interrupts and then point the interrupt handler away from the system handler to our new handler. we can then
    // re-enable scan interupts and exit.
    sei
    lda #<complete_interrupt
    sta interruptPointer.system
    lda #>complete_interrupt
    sta interruptPointer.system+1
    lda CINV
    sta interruptPointer.raster
    lda CINV+1
    sta interruptPointer.raster+1
    // disable raster interrupts
    lda IRQMASK
    and #%0111_1110
    sta IRQMASK
    // set interrupt handler 
    lda #<interrupt_interceptor
    sta CINV
    sta CBINV
    lda #>interrupt_interceptor
    sta CINV+1
    sta CBINV+1
    // set raster line used to trigger on raster interrupt
    // as there are 262 lines, the line number is set by setting the highest bit of $D011 and the 8 bits in $D012
    lda SCROLY
    and #%0111_1111
    sta SCROLY
    lda #251
    sta RASTER
    // reenable raster interrupts
    lda IRQMASK
    ora #%1000_0001
    sta IRQMASK
    cli
    rts

// call our interrupt handlers
// we call a different handler if the interrupt was triggered by a raster line compare event
interrupt_interceptor:
    lda VICIRQ
    and #%0000_0001
    beq raster_interrupt
    sta VICIRQ // needed to clear the interrupt flag
    jmp (interruptPointer.system)
raster_interrupt:
    jmp (interruptPointer.raster)

// minimalist interrupt handler
complete_interrupt:
    pla
    tay
    pla
    tax
    pla
    rti

// clear the video screen area
// loads $00 to the video matrix SCNMEM to SCNMEM+$3E7
clear_screen:
    lda #<SCNMEM
    sta FREEZP+2
    lda #>SCNMEM
    sta FREEZP+3
    ldx #$03
    lda #$00
    tay
!loop:
    sta (FREEZP+2), y
    iny
    bne !loop-
    inc FREEZP+3
    dex 
    bne !loop-
!loop:
    sta (FREEZP+2), y
    iny
    cpy #$e8
    bcc !loop-
    rts    

// clear the video graphics area
clear_sprites:
    lda #<GRPMEM
    sta FREEZP+2
    lda #>GRPMEM
    sta FREEZP+3
    ldx #$10
    lda #$00
    tay
!loop:
    sta (FREEZP+2), y
    iny
    bne !loop-
    inc FREEZP+3
    dex 
    bne !loop-
    // reset sprite positions
    ldx #$07
    sta MSIGX
!loop:
    sta SP0X, x
    dex
    bpl !loop-
    rts

// advance the game state if break/q key is pressed
check_stop_keypess: 
    // go to next state of ESC
    jsr STOP
    beq step_state // Escape pressed
    // go straight to options on Q key press
    cmp #KEY_Q 
    bne !return+
    // wait for key to be released
!loop: 
    jsr STOP
    cmp #KEY_Q
    beq !loop-
    //... TODO: jump to options state - JSR $63F3; JMP $612C
    rts // todo remove
step_state:
    lda new_game_state
    eor #$ff
    sta new_game_state
!loop:
    jsr STOP
    beq !loop-
!return:
    rts

// detect keypress and trigger action based on key
// this function is called during intro, board config and options game states. it allows escape to cancel current state
// and function keys to set game options. eg pressing F1 toggles number of players. you can select this option in 
// any of the non game states. if the game state is not in options state, then the game will jump directly to the
// options state.
check_option_keypress:
    lda LSTX
    cmp #KEY_NONE
    bne process_key
    rts
    // TODO: see 6394
process_key:
    rts

//---------------------------------------------------------------------------------------------------------------------
// Variables
//---------------------------------------------------------------------------------------------------------------------
.segment Variables

// interrupt handler pointers
.namespace interruptPointer {
    system: .word 0 // system interrupt handler
    raster: .word 0 // raster interrupt handler
}

// holds the current state of the game. States are:
// - $00: Scroll in main title (intro_state__scroll_title)
// - $80: **I think this is board setup intro
// - TODO
game_state: .byte $00 

// gets set when to the new game state which causes game state to be updated after the interrupt completes
new_game_state: .byte $00

// current sprite positions
sprite_x_pos: .byte $00, $00, $00, $00, $00, $00, $00, $00
sprite_y_pos: .byte $00, $00, $00, $00, $00, $00, $00, $00

// scratch storage
scratch: .byte $00
